<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>UTC Clock + Solar Times</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+CiAgICA8Y2lyY2xlIGN4PSIzMiIgY3k9IjMyIiByPSIyOCIgZmlsbD0iJTIzMDAwIiBzdHJva2U9IiUyM2NjYyIgc3Ryb2tlLXdpZHRoPSI0Ii8+CiAgICA8Y2lyY2xlIGN4PSIzMiIgY3k9IjMyIiByPSIzIiBmaWxsPSIlMjNjY2MiLz4KICAgIDxsaW5lIHgxPSIzMiIgeTE9IjMyIiB4Mj0iMzIiIHkyPSIxNCIgc3Ryb2tlPSIlMjNjY2MiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIi8+CiAgICA8bGluZSB4MT0iMzIiIHkxPSIzMiIgeDI9IjQ2IiB5Mj0iMzIiIHN0cm9rZT0iJTIzY2NjIiBzdHJva2Utd2lkdGg9IjQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIvPgo8L3N2Zz4=">
  <style>
:root {
    /* shared scales */
    --label-size: clamp(.6rem, 2.2vw, 1rem);
    --content-gutter: 0.8vh;

    /* smooth theme transitions (optional) */
    --theme-transition: color .15s linear, background-color .15s linear, border-color .15s linear;
}

:root,
:root[data-theme="day"] {
    /* Daylight theme */
    --bg: #000000;
    --utc: #7cc7ff;         /* UTC clock */
    --gps: #c792ea;         /* GPS position */
    --sun: #ffb86c;         /* sun times */
    --local: #7bd5a7;       /* local time */
    --status-bg: #0a0a0a;   /* top and bottom bars */
    --status-fg: #c0c0c0;   /* default status */
    --status-ok: #9aff7a;   /* locked */
    --status-warn: #ffd966; /* requesting */
    --status-bad: #ff6b6b;  /* denied */
    --muted: #9aa0a6;
}

/* Night theme with warm, blue-light-reduced  colors*/
:root[data-theme="dim"] {
    --bg: #000000;
    --utc: #ba0000;
    --gps: #a27294;
    --sun: #ce9558;
    --local: #d16507;
    --status-bg: #0b0b0b;
    --status-fg: #89867f;
    --status-ok: #8c9a0f;
    --status-warn: #9f8854;
    --status-bad: #9f4c47;
    --muted: #8f8a80;
}

/* All red theme */
:root[data-theme="red"] {
    --bg: #000000;
    --utc: #bb0000;
    --gps: #880000;
    --sun: #990000;
    --local: #bb0000;
    --status-bg: #0b0000;
    --status-fg: #880000;
    --status-ok: #770000;
    --status-warn: #9f0000;
    --status-bad: #cc0000;
    --muted: #770000;
}

/* Reset boxing, monospace everywhere */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

/* Hide idle mouse pointer */
html, body { cursor: auto; }

/* Master layout */
html {
    height: 100%;
}
body {
    width: 100vw;
    height: 100vh;
    min-height: 100vh;
    overflow: scroll;
    /* padding: var(--content-gutter) var(--content-gutter) 0 var(--content-gutter); */
    color: #ff0000;  /* Highlight unstyled content (should not happen) */
    background: var(--bg);
    transition: var(--theme-transition);
    display: grid;
    grid-template-rows: auto 1fr auto;  /* header, main, footer */
    /* row-gap: var(--content-gutter); */
}

/* Three-row flex layout with header, main, footer */ 
header {
    display: grid;
    grid-template-columns: 1fr auto 1fr;
    color: var(--status-fg);
    background: var(--status-bg);
    font-size: 2.3vw;
    /* padding: .6rem 1rem; */
    justify-content: space-between;
    gap:1rem;
    white-space:nowrap;
    border-bottom: 1px solid #1a1a1a;
    margin-bottom: 2vh;
}
main {
    width: 100%;
    height: 100%;
    min-height: 100%;
    overflow: hidden;
    /* padding: var(--content-gutter) var(--content-gutter) 0 var(--content-gutter); */
    display: grid;
    grid-template-rows: 1fr 1fr;
    /* row-gap: var(--content-gutter); */
}
footer {
    color: var(--status-fg);
    background: var(--status-bg);
    border-top: 1px solid #1a1a1a;
    /* padding: .6rem 1rem; */
    font-size: 2.3vw;
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    white-space: nowrap;
    margin-top: 4vh;
}

/* First article contains UTC, second article contains local times */
article {
    width: 100%;
    height: 100%;
    overflow: hidden;
    /* padding: var(--content-gutter) var(--content-gutter) 0 var(--content-gutter); */
    display: grid;
    /* grid-auto-flow: column; */
    grid-template-rows: 1fr auto;
    /* row-gap: var(--content-gutter); */
}

/* First section is huge clock, second is sun times */
section {
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    /* padding: var(--content-gutter) calc(2vw + var(--content-gutter)); */
    white-space: nowrap; /* no wrapping */
}

/* Reusable layout classes */
.row   { display: flex; flex-direction: row;    align-items: center; justify-content: center; gap: min(5vw, 5vh); }
.stack { display: flex; flex-direction: column; align-items: center; justify-content: center; }
.centered { display: flex; align-items: center; justify-content: center; overflow: hidden; text-align: center; }
.label { font-size: calc(min(var(--label-size), 2.5vh)); color: var(--muted); line-height: 1.1; margin-top: .25em; text-align: center; }
.value { /* typically simple times like 00:00 */
    --chars: 5;
    font-size: calc(min(20vw, 30vh) / var(--chars));
    line-height: 1.1;
    letter-spacing: .04em;
    font-variant-numeric: tabular-nums;
    /* padding:.2em .3em; */
}


/* Individual styling */
#utcSec { color: var(--utc); }
#gpsSec { color: var(--gps); }
#sunUtcSec { color: var(--sun); }
#sunLocalSec { color: var(--sun); }
#localSec { color: var(--local); }
#utcDate, #latVal, #lonVal { color: var(--gps); }
#utcClock, #localTime, #localOffset {
    letter-spacing: .04em;
    font-variant-numeric: tabular-nums;
}
#utcClock {
    --chars: 9;
    font-size: calc(min(130vw, 210vh) / var(--chars));
    line-height: 1;
}
#localRow {
    --chars: 13;
    font-size: calc(min(150vw, 250vh) / var(--chars));
    line-height: 1;
}  

/* Local offset buttons styling */
.btn { font-size: min(9vh, 9vw); color: var(--local); }
.btn:active { transform: translateY(3px); }

/* Status bar styling */
#statusText{ font-variant-numeric: tabular-nums; }
#statusHint { text-align: right; }
#statusHint button{ color: #bbb; cursor: pointer; all: unset; cursor: pointer; text-decoration: none; }
.ok{ color: var(--status-ok); }
.warn{ color: var(--status-warn); }
.bad{ color: var(--status-bad); cursor: pointer; }

</style>
</head>
<body>

  <header id="gpsRow" class="row">
    <div id="utcDate">2000-01-01</div>
    <div id="latVal">--°--.--'N</div>
    <div id="lonVal">---°---.--'W</div>
  </header>

  <main id="mainContent" class="main">
    <article id="utcContent" class="article">

      <!-- UTC Clock (fills) -->
      <section id="utcSec" class="section">
        <div class="stack">
          <div id="utcClock">00:00:00</div>
          <div class="label">UTC</div>
        </div>
      </section>

      <!-- Sun Times in UTC (wraps) -->
      <section id="sunUtcSec" class="section">
        <div id="sunUtcRow" class="row">
          <div class="stack"><div class="value" id="sunriseUTC">--:--</div><div class="label">SUNRISE</div></div>
          <div class="stack"><div class="value" id="noonUTC">--:--</div><div class="label">NOON</div></div>
          <div class="stack"><div class="value" id="sunsetUTC">--:--</div><div class="label">SUNSET</div></div>
          <div class="stack"><div class="value" id="noonOffUTC">±--:--</div><div class="label">LHA</div></div>
        </div>
      </section>

    </article>

    <article id="localContent" class="article">

      <!-- Local Time (fills) -->
      <section id="localSec" class="section">
        <div id="localRow" class="row">
          <div class="stack">
            <div id="localTime">00:00</div>
            <div class="label">LOCAL</div>
          </div>
          <div class="stack">
            <div class="row">
              <span id="localOffset">±00:00</span>
              <span id="btnStack" class="stack">
                <div id="btnPlus" class="btn centered" aria-label="Increase offset">⊕</div>
                <div id="btnMinus" class="btn centered" aria-label="Decrease offset">⊖</div>
              </span>
            </div>
            <div class="label">UTC OFFSET</div>
          </div>
        </div>
      </section>

      <!-- Sun Times in Local (wraps) -->
      <section id="sunLocalSec" class="section">
        <div id="sunLocalRow" class="row">
          <div class="stack"><div class="value" id="sunriseLocal">--:--</div><div class="label">SUNRISE</div></div>
          <div class="stack"><div class="value" id="noonLocal">--:--</div><div class="label">NOON</div></div>
          <div class="stack"><div class="value" id="sunsetLocal">--:--</div><div class="label">SUNSET</div></div>
        </div>
      </section>

    </article>

  </main>

  <!-- Status footer (wraps) -->
  <footer id="statusBar">
    <div id="statusText" class="warn">Requesting position</div>
    <div id="statusHint"><button id="fsToggleBtn">Fullscreen f/ESC</button></div>
  </footer>

  <script>
const pad2 = (n) => String(n).padStart(2,'0');
const sign = (n) => (n < 0 ? '-' : '+');
const fmtUtcIsoDate = (d) => d.toISOString().slice(0, 10);
const isDay = (sunrise, sunset, d) => (sunrise < d) && (d < sunset);

function fmtHHMMSS_UTC(d){
    return `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}:${pad2(d.getUTCSeconds())}`;
}

function fmtHHMM_UTC(d){
    return `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}`;
}

function fmtOffset(minutes){
    const m = Math.abs(minutes);
    const hh = Math.floor(m/60);
    const mm = m % 60;
    return `${sign(minutes)}${pad2(hh)}:${pad2(mm)}`;
}

function clampOffset(mins){
    const lim = 24*60; // ±24h
    return Math.max(-lim, Math.min(lim, mins));
}

// Degrees to degrees+decimal minutes string with padded degrees width
function toDegMinPad(v, posChar, negChar, width){
    const hemi = v >= 0 ? posChar : negChar;
    const av = Math.abs(v);
    const deg = Math.floor(av);
    const min = (av - deg) * 60;
    const degStr = String(deg).padStart(width,'0');
    const minStr = min.toFixed(2).padStart(5,'0'); // 00.00
    return `${degStr}°${minStr}'${hemi}`;
}

// Solar calculations (NOAA)
const ZENITH = 90.833; // degrees
const toRad = (deg) => deg * Math.PI / 180;
const toDeg = (rad) => rad * 180 / Math.PI;

function dayOfYearUTC(date){
    const start = Date.UTC(date.getUTCFullYear(),0,1);
    const now = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
    return Math.floor((now-start)/86400000)+1;
}

function gammaFracYear(date, minutes){
    return 2*Math.PI/365 * (dayOfYearUTC(date)-1 + minutes/1440);
}

function eqTimeDecl(g){
    const eqtime = 229.18*(0.000075 + 0.001868*Math.cos(g) - 0.032077*Math.sin(g) - 0.014615*Math.cos(2*g) - 0.040849*Math.sin(2*g));
    const decl = 0.006918 - 0.399912*Math.cos(g) + 0.070257*Math.sin(g) - 0.006758*Math.cos(2*g) + 0.000907*Math.sin(2*g) - 0.002697*Math.cos(3*g) + 0.00148*Math.sin(3*g);
    return { eqtime, decl };
}

function hourAngleSunrise(latRad, decl){
    const cosH = (Math.cos(toRad(ZENITH)) - Math.sin(latRad)*Math.sin(decl)) / (Math.cos(latRad)*Math.cos(decl));
    if (cosH < -1) return NaN; // polar day
    if (cosH >  1) return NaN; // polar night
    return Math.acos(cosH);
}

function minutesToUTCDate(baseUTC, minutes){
    const d = new Date(Date.UTC(baseUTC.getUTCFullYear(), baseUTC.getUTCMonth(), baseUTC.getUTCDate(), 0,0,0));
    d.setUTCMinutes(Math.round(minutes));
    return d;
}

function solarTimesUTC(baseUTC, latDeg, lonDeg){
    const latRad = toRad(latDeg);
    // estimate / refine solar noon
    let g = gammaFracYear(baseUTC, 0);
    let {eqtime, decl} = eqTimeDecl(g);
    let solNoonMin = 720 - 4*lonDeg - eqtime;
    g = gammaFracYear(baseUTC, solNoonMin);
    ({eqtime, decl} = eqTimeDecl(g));
    solNoonMin = 720 - 4*lonDeg - eqtime;
    const H = hourAngleSunrise(latRad, decl);
    if (!Number.isFinite(H)){
    return { sunrise:null, noon: minutesToUTCDate(baseUTC, solNoonMin), sunset:null, polar:true };
    }
    const delta = toDeg(H)*4;
    return {
    sunrise: minutesToUTCDate(baseUTC, solNoonMin - delta),
    noon:    minutesToUTCDate(baseUTC, solNoonMin),
    sunset:  minutesToUTCDate(baseUTC, solNoonMin + delta),
    polar:   false
    };
}
</script>
  <script>
// Factory that creates a SignalK-backed geolocation object
function createSignalKGeolocation({
  wsUrl = null,
  host = "localhost:3000",
  secure = false,
} = {}) {

  // Build URL if not explicitly provided
  if (!wsUrl) {
    const proto = secure ? "wss://" : "ws://";
    // host may already include a port
    wsUrl = `${proto}${host}/signalk/v1/stream?subscribe=delta`;
  }

  console.log("[SignalK] using WS URL:", wsUrl);

  const GEO_ERROR = {
    PERMISSION_DENIED: 1,
    POSITION_UNAVAILABLE: 2,
    TIMEOUT: 3,
  };

  let ws = null;
  let nextWatchId = 1;
  const watchers = new Map(); // id -> { success, error, options }

  // latest known navigation state
  const state = {
    latitude: null,
    longitude: null,
    altitude: null,
    speed: null,   // m/s
    heading: null, // deg
  };

  let lastPosition = null;

  function makeGeoError(code, message) {
    const err = { code, message };
    err.PERMISSION_DENIED = GEO_ERROR.PERMISSION_DENIED;
    err.POSITION_UNAVAILABLE = GEO_ERROR.POSITION_UNAVAILABLE;
    err.TIMEOUT = GEO_ERROR.TIMEOUT;
    return err;
  }

  function radToDeg(rad) {
    if (rad == null) return null;
    const deg = (rad * 180) / Math.PI;
    return (deg % 360 + 360) % 360;
  }

  function buildPosition(ts) {
    if (state.latitude == null || state.longitude == null) return null;
    return {
      coords: {
        latitude: state.latitude,
        longitude: state.longitude,
        altitude: state.altitude,
        accuracy: 0,
        altitudeAccuracy: null,
        heading: state.heading,
        speed: state.speed,
      },
      timestamp: ts,
    };
  }

  function notifyWatchers(pos) {
    if (!pos) return;
    lastPosition = pos;
    for (const { success } of watchers.values()) {
      try {
        success(pos);
      } catch (e) {
        console.error("[SignalK] watcher callback failed:", e);
      }
    }
  }

  function connect() {
    if (
      ws &&
      (ws.readyState === WebSocket.OPEN ||
        ws.readyState === WebSocket.CONNECTING)
    ) {
      return;
    }

    console.debug("[SignalK] connecting:", wsUrl);
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      console.debug("[SignalK] WS open");
    };

    ws.onmessage = (event) => {
      let msg;
      try {
        msg = JSON.parse(event.data);
      } catch (e) {
        console.error("[SignalK] bad JSON:", e);
        return;
      }
      if (!msg.updates) return;

      for (const u of msg.updates) {
        const ts = u.timestamp ? new Date(u.timestamp).getTime() : Date.now();

        for (const v of u.values || []) {
          const path = v.path;
          const val = v.value;

          // Debug: see what we actually get
          // console.debug("[SignalK] path:", path, "value:", val);

          if (path === "navigation.position" && val && typeof val === "object") {
            state.latitude = val.latitude ?? state.latitude;
            state.longitude = val.longitude ?? state.longitude;
            state.altitude = val.altitude ?? state.altitude;
          } else if (path === "navigation.speedOverGround") {
            if (typeof val === "number") state.speed = val;
          } else if (path === "navigation.courseOverGroundTrue") {
            const deg = radToDeg(val);
            if (deg != null) state.heading = deg;
          }

          const pos = buildPosition(ts);
          if (pos) notifyWatchers(pos);
        }
      }
    };

    ws.onerror = (event) => {
      console.error("[SignalK] WS error", event);
      for (const { error } of watchers.values()) {
        if (!error) continue;
        try {
          error(
            makeGeoError(
              GEO_ERROR.POSITION_UNAVAILABLE,
              "SignalK WebSocket error"
            )
          );
        } catch (e) {
          console.error("[SignalK] error callback failed:", e);
        }
      }
    };

    ws.onclose = (event) => {
      console.debug("[SignalK] WS closed", event.code, event.reason);
      ws = null;
      if (watchers.size > 0) {
        setTimeout(connect, 2000);
      }
    };
  }

  function watchPosition(success, error, options = {}) {
    if (typeof success !== "function") {
      throw new TypeError("watchPosition requires a success callback");
    }

    const id = nextWatchId++;
    watchers.set(id, { success, error, options });

    connect();

    // Immediately give the latest position, if we have one
    if (lastPosition) {
      const maxAge = options.maximumAge;
      if (maxAge == null) {
        try {
          success(lastPosition);
        } catch (e) {
          console.error("[SignalK] watcher immediate callback failed:", e);
        }
      } else {
        const age = Date.now() - lastPosition.timestamp;
        if (age <= maxAge) {
          try {
            success(lastPosition);
          } catch (e) {
            console.error("[SignalK] watcher immediate callback failed:", e);
          }
        }
      }
    }

    return id;
  }

  function clearWatch(id) {
    watchers.delete(id);
    if (watchers.size === 0 && ws) {
      console.debug("[SignalK] no watchers left, closing WS");
      ws.close();
      ws = null;
    }
  }

  function getCurrentPosition(success, error, options = {}) {
    if (typeof success !== "function") {
      throw new TypeError("getCurrentPosition requires a success callback");
    }

    // If we already have something, return it right away
    if (lastPosition) {
      const maxAge = options.maximumAge;
      if (maxAge == null) {
        success(lastPosition);
        return;
      }
      const age = Date.now() - lastPosition.timestamp;
      if (age <= maxAge) {
        success(lastPosition);
        return;
      }
    }

    // Otherwise, do a one-shot watch
    let done = false;
    const watchId = watchPosition(
      (pos) => {
        if (done) return;
        done = true;
        clearWatch(watchId);
        success(pos);
      },
      (err) => {
        if (done) return;
        done = true;
        clearWatch(watchId);
        if (error) error(err);
      },
      options
    );

    // NOTE: we *ignore* options.timeout here for now.
    // If you really want a timeout, you can add a fixed one:
    /*
    const SIGNALK_TIMEOUT_MS = 20000;
    setTimeout(() => {
      if (done) return;
      done = true;
      clearWatch(watchId);
      if (error) {
        error(makeGeoError(GEO_ERROR.TIMEOUT, "SignalK getCurrentPosition timeout"));
      }
    }, SIGNALK_TIMEOUT_MS);
    */
  }

  return {
    getCurrentPosition,
    watchPosition,
    clearWatch,
    GEO_ERROR,
  };
}

</script>
  <script>
// ===== App State =====
const els = {
    utcClock:     document.getElementById('utcClock'),
    utcDate:      document.getElementById('utcDate'),
    localTime:    document.getElementById('localTime'),
    localOffset:  document.getElementById('localOffset'),
    sunriseUTC:   document.getElementById('sunriseUTC'),
    noonUTC:      document.getElementById('noonUTC'),
    noonOffUTC:   document.getElementById('noonOffUTC'),
    sunsetUTC:    document.getElementById('sunsetUTC'),
    sunriseLocal: document.getElementById('sunriseLocal'),
    noonLocal:    document.getElementById('noonLocal'),
    sunsetLocal:  document.getElementById('sunsetLocal'),
    latVal:       document.getElementById('latVal'),
    lonVal:       document.getElementById('lonVal'),
    statusText:   document.getElementById('statusText'),
    btnPlus:      document.getElementById('btnPlus'),
    btnMinus:     document.getElementById('btnMinus'),
    fsToggleBtn:  document.getElementById('fsToggleBtn'),
    gpsRow:       document.getElementById('gpsRow'),
    sunUtcRow:    document.getElementById('sunUtcRow'),
    sunLocalRow:  document.getElementById('sunLocalRow'),
    utcSec:       document.getElementById('utcSec'),
    localRow:     document.getElementById('localRow')
};

let sunrise = null;
let noon = null;
let sunset = null;
let dayTheme = 'day';
let nightTheme = 'red';
let gpsMode = 'browser';
let signalKGeo = null;

// ===== LocalStorage =====
let offsetMinutes = parseInt(localStorage.getItem('localOffsetMinutes') || '0', 10);
offsetMinutes = clampOffset(isNaN(offsetMinutes) ? 0 : offsetMinutes);
let lastCoords = JSON.parse(localStorage.getItem('localLastCoords'));

// ===== Rendering =====
function renderUTC(){
    const now = new Date();
    els.utcDate.textContent = fmtUtcIsoDate(now);
    els.utcClock.textContent = fmtHHMMSS_UTC(now);
    if (sunrise) {
     document.documentElement.setAttribute('data-theme', isDay(sunrise, sunset, now) ? dayTheme : nightTheme);        
    }
}

function renderLocal(){
    const now = new Date();
    const ms = now.getTime() + offsetMinutes*60000; // apply manual offset vs UTC
    const d = new Date(ms);
    els.localTime.textContent = `${pad2(d.getUTCHours())}:${pad2(d.getUTCMinutes())}`; // display as if UTC shifted
    els.localOffset.textContent = fmtOffset(offsetMinutes);
}

function renderGPSAndSun(){
    const todayUTC = new Date();
    const baseUTC = new Date(Date.UTC(todayUTC.getUTCFullYear(), todayUTC.getUTCMonth(), todayUTC.getUTCDate()));

    // GPS
    if (lastCoords){
        const { latitude, longitude } = lastCoords;
        els.latVal.textContent = toDegMinPad(latitude, 'N', 'S', 2);
        els.lonVal.textContent = toDegMinPad(longitude, 'E', 'W', 3);
    } else {
        els.latVal.textContent = "--°--.--'N";
        els.lonVal.textContent = "---°--.--'W";
    }

    // Sun (UTC)
    /* sunrise, noon, sunset are globals */
    if (lastCoords) {
        const sol = solarTimesUTC(baseUTC, lastCoords.latitude, lastCoords.longitude);
        sunrise = sol.sunrise; noon = sol.noon; sunset = sol.sunset;
    }
    els.sunriseUTC.textContent = sunrise ? fmtHHMM_UTC(sunrise) : '--:--';
    const noonOffsetMin = noon ? ((noon.getUTCHours()*60 + noon.getUTCMinutes()) - (12*60)) : 0;
    els.noonOffUTC.textContent = fmtOffset(noonOffsetMin);
    els.sunsetUTC.textContent  = sunset ? fmtHHMM_UTC(sunset) : '--:--';
    els.noonUTC.textContent = noon ? fmtHHMM_UTC(noon) : '--:--';

    // Sun (Local = UTC shifted by manual offset)
    const shift = (d) => d ? new Date(d.getTime() + offsetMinutes*60000) : null;
    const sRiseL = shift(sunrise), sNoonL = shift(noon), sSetL = shift(sunset);
    els.sunriseLocal.textContent = sRiseL ? fmtHHMM_UTC(sRiseL) : '--:--';
    els.noonLocal.firstChild.nodeValue = sNoonL ? fmtHHMM_UTC(sNoonL) : '--:--';
    els.sunsetLocal.textContent  = sSetL ? fmtHHMM_UTC(sSetL) : '--:--';
}

function setStatus(state){
    // state: 'request', 'locked', 'denied'
    if (state === 'request') {
        els.statusText.className = 'warn';
        els.statusText.textContent = 'Requesting location';
        els.statusText.onclick = null;
        } else if (state === 'locked') {
        els.statusText.className = 'ok';
        els.statusText.textContent = 'Locked';
        els.statusText.onclick = null;
    } else if (state === 'denied') {
        els.statusText.className = 'bad';
        els.statusText.textContent = 'No location (click retry)';
        els.statusText.onclick = () => requestLocation(true);
    }
}

// ===== Controls =====
function bumpOffset(delta){
    offsetMinutes = clampOffset(offsetMinutes + delta);
    localStorage.setItem('localOffsetMinutes', String(offsetMinutes));
    renderLocal();
    renderGPSAndSun();
}
document.getElementById('btnPlus').addEventListener('click', () => bumpOffset(+15));
document.getElementById('btnMinus').addEventListener('click', () => bumpOffset(-15));

// Keyboard: + / - adjust offset; f/Esc fullscreen
document.addEventListener('keydown', (e)=>{
    const key = e.key;
    if (key === 'f' || key === 'F') toggleFullscreen();
    if (key === 'Escape' && document.fullscreenElement) document.exitFullscreen().catch(()=>{});
    if (key === '+' || key === '=' || e.code === 'NumpadAdd'){ e.preventDefault(); bumpOffset(+15); }
    if (key === '-' || e.code === 'NumpadSubtract'){ e.preventDefault(); bumpOffset(-15); }
});

// Fullscreen toggle via footer button
function toggleFullscreen(){
    if (!document.fullscreenElement){
        document.documentElement.requestFullscreen().catch(()=>{});
    } else {
        document.exitFullscreen().catch(()=>{});
    }
}
els.fsToggleBtn.addEventListener('click', toggleFullscreen);

// ===== Geolocation =====
const geolocationOptions = {
    enableHighAccuracy: true,
    timeout: 30000,
    maximumAge: 60000
};
let clearWatchID = null;
function geolocationSuccess(pos) {
    // console.debug('Geolocation received:', pos)
    setStatus('locked');
    lastCoords = pos.coords;
    localStorage.setItem('localLastCoords', JSON.stringify(lastCoords));
    renderGPSAndSun();
}
function geolocationError(err) {
    console.error('Geolocation error:', err);
    if (clearWatchID) {
        setStatus('denied');
        clearWatchID();
        clearWatchID = null;
    }
}
function requestLocation() {
    if (gpsMode == 'browser') {
        if (!('geolocation' in navigator)){
            console.warn('Geolocation not supported');
            setStatus('denied');
            return;
        }
        setStatus('request');
        navigator.geolocation.getCurrentPosition(geolocationSuccess, geolocationError, geolocationOptions);
        if (!clearWatchID) {
            const id = navigator.geolocation.watchPosition(geolocationSuccess, geolocationError, geolocationOptions);
            clearWatchID = () => { navigator.geolocation.clearWatch(id) };
        }
    } else if (gpsMode == 'signalk') {
        setStatus('request');
        signalKGeo.getCurrentPosition(geolocationSuccess, geolocationError, geolocationOptions);
        if (!clearWatchID) {
            const id = signalKGeo.watchPosition(geolocationSuccess, geolocationError, geolocationOptions);
            clearWatchID = () => { signalKGeo.clearWatch(id) };
        }
    }
}

// Parse query parameters from the current URL
const p = new URLSearchParams(window.location.search);
if (p.has('day')) { dayTheme = p.get('day'); document.documentElement.setAttribute('data-theme', dayTheme); }
if (p.has('night')) { nightTheme = p.get('night'); }
if (p.has('signalk')) { gpsMode = 'signalk'; }

if (gpsMode == 'signalk') {
    signalKGeo = createSignalKGeolocation({
        host: p.get('signalk'),
        secure: false,
    });
}
console.debug("gpsMode:", gpsMode);

// Clocks update every second
setInterval(() => { renderUTC(); renderLocal(); }, 1000); // every second

// Initial paint
renderUTC();
renderLocal();
requestLocation();
renderGPSAndSun();
</script>
</body>
</html>